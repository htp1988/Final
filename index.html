<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Medicaid Enrollment Trends (2014–2021)</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    :root {
      --blue: #1f77b4;
      --orange: #ff7f0e;
      --green: #2ca02c;
      --border: #dddddd;
      --bg: #fafafa;
      --text-muted: #666666;
    }

    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f6f6f6;
    }

    .page-wrap {
      max-width: 1100px;
      margin: 0 auto;
      background: white;
      padding: 20px 24px 28px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.06);
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 12px;
      margin-bottom: 8px;
    }

    h1 {
      margin: 0;
      font-size: 1.6rem;
    }

    .nav-links a {
      margin-left: 14px;
      font-size: 0.9rem;
      font-weight: 600;
      color: #1f4f8f;
      text-decoration: none;
    }

    .nav-links a:first-child {
      margin-left: 0;
    }

    .nav-links a:hover {
      text-decoration: underline;
    }

    #controls {
      margin: 14px 0 10px 0;
      padding: 10px 12px;
      border-radius: 10px;
      background: #f3f7fb;
      border: 1px solid #d7e2f4;
      display: flex;
      flex-wrap: wrap;
      gap: 18px;
      align-items: center;
    }

    label {
      font-size: 0.9rem;
      font-weight: 600;
    }

    select {
      padding: 4px 6px;
      font-size: 0.9rem;
      border-radius: 4px;
      border: 1px solid #cccccc;
      background: white;
    }

    #mode-controls {
      font-size: 0.9rem;
    }

    #mode-controls label {
      font-weight: normal;
      margin-right: 8px;
    }

    .zoom-controls button {
      margin-right: 6px;
      padding: 4px 8px;
      font-size: 0.85rem;
      border-radius: 4px;
      border: 1px solid #c0c0c0;
      background: #ffffff;
      cursor: pointer;
    }

    .zoom-controls button:hover {
      background: #eef3ff;
    }

    svg {
      border: 1px solid var(--border);
      background: var(--bg);
      margin-top: 6px;
      border-radius: 3px;
    }

    .axis path,
    .axis line {
      stroke: #cccccc;
    }

    .line {
      fill: none;
      stroke-width: 2.5px;
    }

    .line.total {
      stroke: var(--blue);
    }

    .line.viii {
      stroke: var(--orange);
    }

    .line.newly {
      stroke: var(--green);
    }

    .line.share_viii {
      stroke: var(--orange);
    }

    .line.share_newly {
      stroke: var(--green);
    }

    .chart-title {
      font-weight: bold;
      margin-top: 10px;
      margin-bottom: 4px;
    }

    .legend {
      font-size: 0.8rem;
      cursor: pointer;
    }

    .legend rect {
      stroke: none;
    }

    /* Dim non-focused legend items when focusing */
    .legend.dim text {
      opacity: 0.35;
    }

    .legend.dim rect {
      opacity: 0.3;
    }

    .tooltip {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      padding: 6px 8px;
      font-size: 0.8rem;
      pointer-events: none;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
      z-index: 10;
    }

    .no-data {
      font-size: 0.85rem;
      fill: var(--text-muted);
    }

    .hint {
      margin-top: 6px;
      font-size: 0.8rem;
      color: var(--text-muted);
    }
  </style>
</head>
<body>
  <div class="page-wrap">
    <div class="top-bar">
      <h1>Medicaid Enrollment Trends (2014–2021)</h1>
      <div class="nav-links">
        <a href="doc.html">Documentation</a>
        <!-- Replace with your real YouTube URL -->
        <a href="https://youtu.be/YOUR_VIDEO_ID" target="_blank">Demo video</a>
      </div>
    </div>

    <div id="controls">
      <div>
        <label for="state-select">State:</label>
        <select id="state-select"></select>
      </div>

      <div id="mode-controls">
        <label>
          <input type="radio" name="mode" value="counts" checked />
          Enrollment counts
        </label>
        <label>
          <input type="radio" name="mode" value="share" />
          Expansion share (%)
        </label>
      </div>

      <div class="zoom-controls">
        <button id="zoom-in">Zoom in</button>
        <button id="zoom-out">Zoom out</button>
        <button id="zoom-reset">Reset</button>
      </div>
    </div>

    <div class="chart-title" id="chart-title">
      Enrollment counts for selected state
    </div>
    <svg id="chart" width="900" height="420"></svg>
    <div class="hint">
      Use Zoom in / Zoom out / Reset to adjust the time range.
      Drag left or right inside the chart to move the time window.
      Click legend items to focus on one line; click again to go back.
    </div>

    <div id="tooltip" class="tooltip" style="opacity: 0;"></div>
  </div>

  <script>
    const svg = d3.select("#chart");
    const margin = { top: 50, right: 40, bottom: 50, left: 80 };
    const width = +svg.attr("width") - margin.left - margin.right;
    const height = +svg.attr("height") - margin.top - margin.bottom;

    const chartG = svg.append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    const defs = svg.append("defs");
    defs.append("clipPath")
      .attr("id", "plot-clip")
      .append("rect")
      .attr("width", width)
      .attr("height", height);

    const plotArea = chartG.append("g")
      .attr("class", "plot-area")
      .attr("clip-path", "url(#plot-clip)");

    const xScale = d3.scaleTime().range([0, width]);
    const yScale = d3.scaleLinear().range([height, 0]);

    const xAxisG = chartG.append("g")
      .attr("class", "axis x-axis")
      .attr("transform", `translate(0,${height})`);

    const yAxisG = chartG.append("g")
      .attr("class", "axis y-axis");

    chartG.append("text")
      .attr("text-anchor", "middle")
      .attr("x", width / 2)
      .attr("y", height + 40)
      .style("font-size", "0.8rem")
      .text("Time");

    const yLabel = chartG.append("text")
      .attr("text-anchor", "middle")
      .attr("transform", "rotate(-90)")
      .attr("x", -height / 2)
      .attr("y", -60)
      .style("font-size", "0.8rem")
      .text("Number of enrollees");

    const tooltip = d3.select("#tooltip");

    const overlay = plotArea.append("rect")
      .attr("width", width)
      .attr("height", height)
      .style("fill", "none")
      .style("pointer-events", "all");

    const dateFmt = d3.timeFormat("%Y-%m");
    const numFmt = d3.format(",.0f");
    const pctFmt = d3.format(".1f");
    const bisectDate = d3.bisector(d => d.date).left;

    const stateSelect = d3.select("#state-select");
    const modeInputs = d3.selectAll("input[name='mode']");
    const chartTitle = d3.select("#chart-title");

    const zoomInBtn = d3.select("#zoom-in");
    const zoomOutBtn = d3.select("#zoom-out");
    const zoomResetBtn = d3.select("#zoom-reset");

    // Drag for horizontal pan
    let isDragging = false;
    let dragStartX = null;
    let dragStartXDomain = null;

    function normalizeStateName(name) {
      if (!name) return name;
      let cleaned = name.replace(/\*/g, "").trim();
      const lower = cleaned.toLowerCase();

      // American Samoa variations
      if (lower.startsWith("amer.") && lower.includes("samoa")) {
        return "American Samoa";
      }
      if (lower === "american samoa") {
        return "American Samoa";
      }

      // District of Columbia variations
      if (lower.startsWith("dist.") && lower.includes("col")) {
        return "District of Columbia";
      }
      if (lower === "district of columbia" || lower === "district of columbia.") {
        return "District of Columbia";
      }

      return cleaned;
    }

    function displayStateName(s) {
      return s === "Totals" ? "United States (total)" : s;
    }

    const legendConfigCounts = [
      { id: "total",  label: "Total Medicaid enrollees", color: "#1f77b4" },
      { id: "viii",   label: "VIII group enrollees",     color: "#ff7f0e" },
      { id: "newly",  label: "Newly eligible VIII enrollees", color: "#2ca02c" }
    ];

    const legendConfigShare = [
      { id: "share_viii",  label: "VIII group \u00f7 Total Medicaid",         color: "#ff7f0e" },
      { id: "share_newly", label: "Newly eligible VIII \u00f7 Total Medicaid", color: "#2ca02c" }
    ];

    let rawData = [];
    let currentState = null;
    let currentMode = "counts";
    let currentSeriesData = [];
    let fullDomain = null;     // full x-domain for state

    let focusedCountsId = null;
    let focusedShareId  = null;

    const legendG = chartG.append("g")
      .attr("class", "legend")
      .attr("transform", "translate(0,-30)");

    const noDataText = chartG.append("text")
      .attr("class", "no-data")
      .attr("x", width / 2)
      .attr("y", height / 2)
      .attr("text-anchor", "middle")
      .style("display", "none")
      .text("No data for this state.");

    const lineGenerator = d3.line()
      .defined(d => d.value != null && !isNaN(d.value))
      .x(d => xScale(d.date))
      .y(d => yScale(d.value));

    const lineGroup = plotArea.append("g");

    function drawXAxis() {
      const domain = xScale.domain();
      const spanMs = domain[1] - domain[0];
      const spanMonths = spanMs / (1000 * 60 * 60 * 24 * 30);

      let xAxis;
      if (spanMonths <= 18) {
        xAxis = d3.axisBottom(xScale)
          .ticks(d3.timeMonth.every(3))
          .tickFormat(d3.timeFormat("%b %Y"));
      } else {
        xAxis = d3.axisBottom(xScale)
          .ticks(d3.timeYear.every(1))
          .tickFormat(d3.timeFormat("%Y"));
      }

      xAxisG.transition().call(xAxis);
    }

    function zoomBy(factor) {
      if (!fullDomain) return;

      const domain = xScale.domain();
      const center = (domain[0].getTime() + domain[1].getTime()) / 2;
      const span = domain[1] - domain[0];
      const fullSpan = fullDomain[1] - fullDomain[0];

      let newSpan = span * factor;
      const minSpan = 1000 * 60 * 60 * 24 * 90; // ~3 months
      const maxSpan = fullSpan;
      if (factor < 1 && newSpan < minSpan) newSpan = minSpan;
      if (factor > 1 && newSpan > maxSpan) newSpan = maxSpan;

      let newStart = new Date(center - newSpan / 2);
      let newEnd = new Date(center + newSpan / 2);

      if (newStart < fullDomain[0]) {
        newStart = fullDomain[0];
        newEnd = new Date(newStart.getTime() + newSpan);
      }
      if (newEnd > fullDomain[1]) {
        newEnd = fullDomain[1];
        newStart = new Date(newEnd.getTime() - newSpan);
      }

      xScale.domain([newStart, newEnd]);
      updateChart(currentState, currentMode, true);
    }

    d3.csv("medicaid_12012025.csv", d3.autoType)
      .then(data => {
        data.forEach(d => {
          d.State = normalizeStateName(d.State);
        });

        data = data.filter(d =>
          d["Enrollment Year"] >= 2014 &&
          d["Enrollment Year"] <= 2021
        );

        data.forEach(d => {
          d.date = new Date(d["Enrollment Year"], d["Enrollment Month"] - 1, 1);
        });

        rawData = data;

        let states = Array.from(new Set(rawData.map(d => d.State)));
        const hasTotals = states.includes("Totals");
        if (hasTotals) {
          states = states.filter(s => s !== "Totals");
          states.sort(d3.ascending);
          states.unshift("Totals");
        } else {
          states.sort(d3.ascending);
        }

        stateSelect.selectAll("option")
          .data(states)
          .enter()
          .append("option")
          .attr("value", d => d)
          .text(d => displayStateName(d));

        const defaultState = hasTotals ? "Totals" : states[0];
        stateSelect.property("value", defaultState);
        currentState = defaultState;

        stateSelect.on("change", () => {
          currentState = stateSelect.property("value");
          fullDomain = null;
          focusedCountsId = null;
          focusedShareId  = null;
          updateChart(currentState, currentMode, false);
        });

        modeInputs.on("change", (event) => {
          currentMode = event.target.value;
          focusedCountsId = null;
          focusedShareId  = null;
          fullDomain = null;
          updateChart(currentState, currentMode, false);
        });

        zoomInBtn.on("click", () => zoomBy(0.5));
        zoomOutBtn.on("click", () => zoomBy(2));
        zoomResetBtn.on("click", () => {
          if (!fullDomain) return;
          xScale.domain(fullDomain);
          focusedCountsId = focusedCountsId; // keep focus, but reset x
          focusedShareId  = focusedShareId;
          updateChart(currentState, currentMode, true);
        });

        overlay
          .on("mousedown", function(event) {
            if (!fullDomain) return;
            isDragging = true;
            const [mx] = d3.pointer(event, this);
            dragStartX = mx;
            dragStartXDomain = xScale.domain().map(d => new Date(d));
          });

        d3.select(window).on("mouseup", () => {
          isDragging = false;
        });

        overlay
          .on("mousemove", function(event) {
            const [mx] = d3.pointer(event, this);

            if (isDragging && dragStartXDomain && fullDomain) {
              const dx = mx - dragStartX;
              const xSpan = dragStartXDomain[1] - dragStartXDomain[0];
              const offsetMs = -dx / width * xSpan;

              let newStart = new Date(dragStartXDomain[0].getTime() + offsetMs);
              let newEnd   = new Date(dragStartXDomain[1].getTime() + offsetMs);

              if (newStart < fullDomain[0]) {
                newStart = fullDomain[0];
                newEnd = new Date(newStart.getTime() + xSpan);
              }
              if (newEnd > fullDomain[1]) {
                newEnd = fullDomain[1];
                newStart = new Date(newEnd.getTime() - xSpan);
              }

              xScale.domain([newStart, newEnd]);
              updateChart(currentState, currentMode, true);
              return;
            }

            // Tooltip (no drag)
            if (!currentSeriesData.length) return;

            const x0 = xScale.invert(mx);
            const refSeries = currentSeriesData[0];
            if (!refSeries || !refSeries.values.length) return;

            const i = bisectDate(refSeries.values, x0, 1);
            if (i <= 0 || i >= refSeries.values.length) return;

            const d0 = refSeries.values[i - 1];
            const d1 = refSeries.values[i];
            const d = x0 - d0.date > d1.date - x0 ? d1 : d0;
            const dateKey = +d.date;

            let html = `<strong>${displayStateName(currentState)}</strong><br/>${dateFmt(d.date)}<br/>`;

            if (currentMode === "counts") {
              currentSeriesData.forEach(series => {
                const pt = series.values.find(p => +p.date === dateKey);
                if (pt && pt.value != null) {
                  html += `${series.label}: ${numFmt(pt.value)}<br/>`;
                }
              });
            } else {
              currentSeriesData.forEach(series => {
                const pt = series.values.find(p => +p.date === dateKey);
                if (pt && pt.value != null) {
                  html += `${series.label}: ${pctFmt(pt.value)}%<br/>`;
                }
              });
            }

            tooltip
              .style("opacity", 1)
              .html(html)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseleave", () => {
            isDragging = false;
            tooltip.style("opacity", 0);
          });

        updateChart(currentState, currentMode, false);
      })
      .catch(err => {
        console.error("Error loading CSV:", err);
        alert("Cannot load medicaid_12012025.csv. Make sure it is in the same folder and served over HTTP(s).");
      });

    function updateChart(stateName, mode, keepXDomain) {
      const stateRows = rawData.filter(d => d.State === stateName);

      if (!stateRows.length) {
        noDataText.style("display", null);
        lineGroup.selectAll("path.series").remove();
        currentSeriesData = [];
        return;
      } else {
        noDataText.style("display", "none");
      }

      stateRows.sort((a, b) => a.date - b.date);

      let seriesDataAll = [];

      if (mode === "counts") {
        chartTitle.text(`Enrollment counts for ${displayStateName(stateName)}`);
        yLabel.text("Number of enrollees");

        seriesDataAll = [
          {
            id: "total",
            label: "Total Medicaid enrollees",
            color: "#1f77b4",
            values: stateRows.map(d => ({
              date: d.date,
              value: d["Total Medicaid Enrollees"]
            })).filter(d => d.value != null && !isNaN(d.value))
          },
          {
            id: "viii",
            label: "VIII group enrollees",
            color: "#ff7f0e",
            values: stateRows.map(d => ({
              date: d.date,
              value: d["Total VIII Group Enrollees"]
            })).filter(d => d.value != null && !isNaN(d.value))
          },
          {
            id: "newly",
            label: "Newly eligible VIII enrollees",
            color: "#2ca02c",
            values: stateRows.map(d => ({
              date: d.date,
              value: d["Total VIII Group Newly Eligible Enrollees"]
            })).filter(d => d.value != null && !isNaN(d.value))
          }
        ];
      } else {
        chartTitle.text(`Expansion share for ${displayStateName(stateName)}`);
        yLabel.text("Expansion share (%)");

        seriesDataAll = [
          {
            id: "share_viii",
            label: "VIII group \u00f7 Total Medicaid",
            color: "#ff7f0e",
            values: stateRows.map(d => {
              const total = d["Total Medicaid Enrollees"];
              const viii = d["Total VIII Group Enrollees"];
              const share = (total && viii) ? (viii / total) * 100 : null;
              return { date: d.date, value: share };
            }).filter(d => d.value != null && !isNaN(d.value))
          },
          {
            id: "share_newly",
            label: "Newly eligible VIII \u00f7 Total Medicaid",
            color: "#2ca02c",
            values: stateRows.map(d => {
              const total = d["Total Medicaid Enrollees"];
              const newly = d["Total VIII Group Newly Eligible Enrollees"];
              const share = (total && newly) ? (newly / total) * 100 : null;
              return { date: d.date, value: share };
            }).filter(d => d.value != null && !isNaN(d.value))
          }
        ];
      }

      currentSeriesData = seriesDataAll;

      if (!seriesDataAll.length || !seriesDataAll[0].values.length) {
        lineGroup.selectAll("path.series").remove();
        noDataText.style("display", null);
        return;
      }

      if (!keepXDomain || !fullDomain) {
        fullDomain = d3.extent(stateRows, d => d.date);
        xScale.domain(fullDomain);
      }

      const domain = xScale.domain();

      // Decide which series to use for y scaling: focused or all
      let focusId = (mode === "counts") ? focusedCountsId : focusedShareId;
      let domainSeries;
      if (focusId) {
        domainSeries = seriesDataAll.filter(s => s.id === focusId);
      } else {
        domainSeries = seriesDataAll;
      }

      const visibleValues = domainSeries.flatMap(s =>
        s.values
          .filter(v => v.date >= domain[0] && v.date <= domain[1])
          .map(v => v.value)
      );

      let minVal = d3.min(visibleValues);
      let maxVal = d3.max(visibleValues);
      if (minVal == null || maxVal == null) {
        minVal = 0;
        maxVal = (mode === "share") ? 100 : 1;
      }

      const range = (maxVal - minVal) || maxVal || 1;
      const padding = range * 0.1;

      if (mode === "share") {
        yScale.domain([
          Math.max(0, minVal - padding),
          Math.min(100, maxVal + padding)
        ]);
      } else {
        yScale.domain([
          Math.max(0, minVal - padding),
          maxVal + padding
        ]);
      }

      drawXAxis();

      if (mode === "share") {
        yAxisG.transition().call(
          d3.axisLeft(yScale).ticks(6).tickFormat(d => d + "%")
        );
      } else {
        yAxisG.transition().call(
          d3.axisLeft(yScale).ticks(6).tickFormat(d3.format(".2s"))
        );
      }

      const legendConfig = mode === "counts" ? legendConfigCounts : legendConfigShare;

      const legendItems = legendG.selectAll("g.legend-item")
        .data(legendConfig, d => d.id);

      const legendEnter = legendItems.enter()
        .append("g")
        .attr("class", "legend-item")
        .attr("transform", (d, i) => `translate(${i * 250},0)`);

      legendEnter.append("rect")
        .attr("x", 0)
        .attr("y", -10)
        .attr("width", 12)
        .attr("height", 12)
        .attr("fill", d => d.color);

      legendEnter.append("text")
        .attr("x", 18)
        .attr("y", 0)
        .attr("alignment-baseline", "middle")
        .text(d => d.label);

      const legendMerge = legendItems.merge(legendEnter)
        .attr("transform", (d, i) => `translate(${i * 250},0)`);

      legendMerge.select("rect").attr("fill", d => d.color);
      legendMerge.select("text").text(d => d.label);

      // Legend click: toggle focus
      legendMerge.on("click", (event, d) => {
        if (mode === "counts") {
          focusedCountsId = (focusedCountsId === d.id) ? null : d.id;
        } else {
          focusedShareId  = (focusedShareId === d.id) ? null : d.id;
        }
        updateChart(currentState, currentMode, true);
      });

      legendItems.exit().remove();

      legendG.selectAll("g.legend-item")
        .classed("dim", d => {
          const focus = (mode === "counts") ? focusedCountsId : focusedShareId;
          return focus && d.id !== focus;
        });

      const lines = lineGroup.selectAll("path.series")
        .data(seriesDataAll, d => d.id);

      lines.enter()
        .append("path")
        .attr("class", d => `line series ${d.id}`)
        .attr("stroke", d => d.color)
        .merge(lines)
        .transition()
        .attr("d", d => lineGenerator(d.values))
        .style("opacity", d => {
          const focus = (mode === "counts") ? focusedCountsId : focusedShareId;
          return focus && d.id !== focus ? 0.25 : 1;
        });

      lines.exit().remove();
    }
  </script>
</body>
</html>
